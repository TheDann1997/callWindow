<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>One-to-One Call Integrado</title>
  <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
  <style>
     body {
      margin: 0;
      font-family: sans-serif;
      background: rgba(58, 70, 96, 0.2);
    }
    .call-window {
      display: flex;
      height: 100vh;
    }
    .sidebar {
      background: linear-gradient(to bottom, #ffffff, #0a2b5c);
      padding: 20px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      width: 1px;
      overflow: hidden;
      transition: width 0.4s ease;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
    }
    .sidebar:hover { width: 60px; }
    .sidebar .side-btn {
      background: #2c2f36;
      color: white;
      width: 50px; height: 50px;
      border-radius: 12px;
      display: flex; align-items: center; justify-content: center;
      font-size: 24px; opacity: 0;
      transition: opacity 0.3s ease, background 0.3s ease;
      border: none; cursor: pointer;
    }
    .sidebar:hover .side-btn { opacity: 1; }
    .sidebar .side-btn:hover { background: #3a3f46; }
    .end-call { background: red !important; }
    .main-call {
      flex: 1;
      display: flex;
      flex-direction: row;
      position: relative;
      overflow: hidden;
      background: linear-gradient(to bottom, #ffffff, #0a2b5c);
      transition: all 0.4s ease;
      height: 100vh;
    }
    .video-area {
      flex: 1;
      min-width: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      border-radius: 20px 0 0 20px; /* Solo borde redondeado a la izquierda */
      overflow: hidden;
    }
    .video-main, .video-mini, .screen-share {
      background: linear-gradient(to bottom, #1f2634, #3a4660);
      border: 2px solid #fff; border-radius: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
      display: flex; align-items: center; justify-content: center;
      transition: all 0.4s ease; overflow: hidden;
      animation: pulse-border 2s infinite;
      position: absolute;
    }
    .video-main {
      background: linear-gradient(to bottom, #0a2b5c, #ffffff);
      width: 98%; height: 99%;
      top: 0; left: 0;
      position: absolute;
    }
    .video-mini {
      background: linear-gradient(to bottom, #ffffff, #0a2b5c);
      width: 200px; height: 120px;
      bottom: 30px; right: 50px;
      border-radius: 12px;
      position: absolute;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;	  
    }
	
.video-main video,
.video-mini video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  background: linear-gradient(to bottom, #ffffff, #0a2b5c);
}
	
    .screen-share {
      display: none;
      justify-content: center; align-items: center;
      color: white; font-size: 24px; padding: 20px;
      box-sizing: border-box; text-align: center;
      width: 100%; height: 100%; border-radius: 20px;
      background: linear-gradient(to bottom, #1f2634, #3a4660);
      border: 2px solid #fff; box-shadow: 0 2px 10px rgba(0,0,0,0.4);
      top: 0; left: 0;
      position: absolute;
      z-index: 1;
    }
    .avatar {
      position: absolute;
      background: rgba(255,255,255,0.2);
      border: 2px solid white; color: white;
      width: 60px; height: 60px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      backdrop-filter: blur(4px); animation: pulse-border 2s infinite;
      left: 50%; top: 50%; transform: translate(-50%, -50%);
      z-index: 2;
      font-size: 20px;
    }
    .video-main .avatar { width: 80px; height: 80px; font-size: 24px; }
    @keyframes pulse-border {
      0% { box-shadow: 0 0 0 0 rgba(255,255,255,0.5); }
      70% { box-shadow: 0 0 0 10px rgba(255,255,255,0); }
      100% { box-shadow: 0 0 0 0 rgba(255,255,255,0); }
    }
    .mini-name {
      position: absolute; bottom: 8px; left: 8px;
      background: rgba(0,0,0,0.6); color: white;
      padding: 2px 6px; border-radius: 6px;
      font-size: 10px; z-index: 2;
    }

    /* -------- PANEL DE MINIATURAS CENTRADO Y FIJO A LA DERECHA -------- */
  .miniaturas-panel {
  display: none;
  margin-top: 30px;
  flex-direction: column;
  align-items: center;        /* o flex-start si quieres pegadas a la izquierda */
  justify-content: flex-start; /* PEGADAS ARRIBA */
  gap: 10px;
  width: 250px;
  height: 100vh;
  background: transparent;
  z-index: 10;
}
.miniaturas-panel .video-mini {
  position: relative !important;
  margin: 0;
  margin-left: 100px;   /* mueve cada miniatura a la izquierda dentro del panel */
  width: 220px;
  height: 130px;
  border-radius: 16px;
  box-sizing: border-box;
  background: linear-gradient(to bottom, #1f2634, #3a4660);
  border: 2px solid #fff;
  box-shadow: 0 2px 10px rgba(0,0,0,0.20);
  display: flex;
  align-items: center;
  justify-content: center;
}
    .miniaturas-panel .avatar {
      width: 60px; height: 60px; font-size: 22px;
      left: 50%; top: 38%;
      transform: translate(-50%, -50%);
      position: absolute;
      border-radius: 50%;
      border: 2px solid #fff;
      background: transparent;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      box-shadow: 0 0 0 2px #fff4, 0 0 15px #fff4;
    }
    .miniaturas-panel .mini-name {
      position: absolute;
      left: 12px; bottom: 12px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 3px 10px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
    }
    /* Oculta los videos flotantes en pantalla compartida */
    .main-call.screen-mode .video-area .video-main,
    .main-call.screen-mode .video-area .video-mini {
      display: none !important;
    }
    .main-call.screen-mode .screen-share {
      display: flex !important;
    }
    /* Muestra las miniaturas SOLO en screen-mode */
    .main-call.screen-mode .miniaturas-panel {
      display: flex;
    }
    /* Miniatura flotante sólo en modo normal */
    .main-call:not(.screen-mode) .video-area .video-mini {
      display: flex;
    }
    .main-call.screen-mode .video-area .video-mini {
      display: none !important;
    }
    /* Ocultar miniaturas panel fuera de screen-mode */
    .main-call:not(.screen-mode) .miniaturas-panel {
      display: none !important;
    }
    /* Ajusta el chat para que esté a la derecha si está activo */
    .call-chat {
      width: 0; transition: width 0.4s ease; overflow: hidden;
      background: rgba(255,255,255,0.2); backdrop-filter: blur(8px);
      border-left: 2px solid rgba(255,255,255,0.15);
      border-top-left-radius: 20px; border-bottom-left-radius: 20px;
      display: flex; flex-direction: column;
      height: 100vh;
    }
    .call-chat.active { width: 300px; }
    .chat-header {
      padding: 15px; color: black; font-weight: bold;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    .chat-messages {
      flex: 1; padding: 10px; overflow-y: auto;
      display: flex; flex-direction: column; gap: 8px;
    }
    .chat-message { display: flex; }
    .chat-message.user { justify-content: flex-end; }
    .chat-message.remote { justify-content: flex-start; }
    .bubble {
      max-width: 70%; padding: 10px; border-radius: 16px;
      background: rgba(255,255,255,0.7); color: #333; word-wrap: break-word;
      border: 1px solid rgba(255,255,255,0.3);
    }
    .chat-message.user .bubble { background: #3a4660; color: white; }
    .chat-input {
      display: flex; padding: 10px; gap: 5px;
    }
    .chat-input input {
      flex: 1; padding: 8px; border: none; border-radius: 5px;
    }
    .chat-input button {
      padding: 8px 12px; background: #3a4660;
      border: none; color: white; border-radius: 5px; cursor: pointer;
    }
    #emojiPanel {
      position: absolute; top: 80px; left: 20px;
      background: rgba(255,255,255,0.8); padding: 10px;
      border-radius: 12px; display: none; flex-wrap: wrap;
      max-width: 150px; z-index: 999;
    }
    .emoji-float {
      position: fixed; top:50%; left:50%;
      transform: translate(-50%,-50%) scale(0);
      opacity:0; font-size:100px; pointer-events:none;
      transition: all 0.5s ease; z-index:9999;
    }
    .emoji-float.show {
      transform: translate(-50%,-50%) scale(1); opacity:1;
    }
	
	 .screen-share video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 20px;
    }
  </style>
</head>
<body>
 <div class="call-window">
    <aside class="sidebar">
      <button class="side-btn" id="chatToggle"><i class="ph ph-chat-centered-dots"></i></button>
      <button class="side-btn toggle-camera" data-active="true"><i class="ph ph-camera"></i></button>
      <button class="side-btn toggle-mic" data-active="true"><i class="ph ph-microphone"></i></button>
      <button class="side-btn" id="screenToggle"><i class="ph ph-monitor"></i></button>
      <button class="side-btn toggle-emoji" id="emojiToggle"><i class="ph ph-smiley"></i></button>
      <button class="side-btn end-call"><i class="ph ph-phone-disconnect"></i></button>
	  
	 <input type="text" id="userIdInput" placeholder="Tu ID" style="width: 50px; padding: 5px; font-size: 12px; border-radius: 8px; border: none;">
<button class="side-btn" id="startConnectionBtn"><i class="ph ph-plug"></i></button>

	  <div style="width: 100%; display: flex; flex-direction: column; align-items: center; gap: 5px; padding: 5px;">
  <input id="remoteIdInput" type="text" placeholder="ID remoto" style="width: 90%; padding: 4px; border-radius: 6px; border: none; text-align: center;" />
  <button id="btnLlamar" class="side-btn" style="width: 90%; font-size: 14px; padding: 6px;">Llamar</button>
</div>

	  
    </aside>

    <main class="main-call" id="mainCall">
      <div id="emojiPanel">
        <span>😀</span><span>😂</span><span>😍</span><span>👍</span>
        <span>😭</span><span>😡</span><span>😎</span><span>🙌</span>
        <span>👏</span><span>🔥</span><span>💯</span><span>❤️</span>
      </div>

      <div class="video-area">
        <!-- Video principal grande (normal mode o pantalla compartida) -->
        <div class="video-main" id="videoMainContainer">
          <video id="mainVideo" autoplay></video>
          <div class="avatar" id="mainAvatar">DA</div>
          <div class="mini-name" id="mainName">Daniel</div>
        </div>
        <!-- Miniatura flotante abajo derecha (solo modo normal) -->
        <div class="video-mini" id="miniaturaNormal">
          <video id="miniLocalNormal" autoplay muted></video>
          <div class="avatar">YM</div>
          <div class="mini-name">Yolanda</div>
        </div>
      </div>

      <!-- Miniaturas en screen-mode, CENTRADAS Y VERTICALES, NO SE MONTAN -->
      <div class="miniaturas-panel" id="miniaturasPanel">
        <!-- Se llenará dinámicamente -->
      </div>

      <div class="call-chat" id="callChat">
        <div class="chat-header">Chat de llamada</div>
        <div class="chat-messages">
          <div class="chat-message remote"><div class="bubble">Hola, revisa esta imagen:</div></div>
          <div class="chat-message remote">
            <div class="bubble">
              <img src="data:image/jpeg;base64,..." alt="Imagen compartida" style="width:100%;border-radius:8px;" />
            </div>
          </div>
          <div class="chat-message user"><div class="bubble">Listo, ¿me puedes pasar el archivo?</div></div>
        </div>
        <div class="chat-input">
          <input type="text" placeholder="Escribe un mensaje..." />
          <button>Enviar</button>
        </div>
      </div>
    </main>
    
    <div class="emoji-float" id="emojiFloat"></div>
  </div>

  <script src="https://unpkg.com/@phosphor-icons/web"></script>

  <script>
  
    const chatButton = document.getElementById('chatToggle');
    const callChat = document.getElementById('callChat');
    const mainCall = document.getElementById('mainCall');
    const emojiToggle = document.getElementById('emojiToggle');
    const emojiPanel = document.getElementById('emojiPanel');
    const emojiFloat = document.getElementById('emojiFloat');
    const screenToggle = document.getElementById('screenToggle');
    // Elimina referencias a remoteVideo y localVideo, usa mainVideo y miniLocalNormal
    const mainVideo = document.getElementById("mainVideo");
    const miniLocalNormal = document.getElementById("miniLocalNormal");
    const remoteIdInput = document.getElementById("remoteIdInput");
    const btnLlamar = document.getElementById("btnLlamar");
    const startConnectionBtn = document.getElementById("startConnectionBtn");
    const userIdInput = document.getElementById("userIdInput");

    let localStream = null;
    let remoteStream = null;
    let pc = null;
    let connection = null;
    let localUserId = null;
    let remoteUserId = null;
    let pendingCandidates = [];

    function createPeerConnection() {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });
      remoteStream = new MediaStream();
      // No asignar a remoteVideo.srcObject, sino actualizar el stream en el layout cuando sea necesario
      pc.onicecandidate = event => {
        if (event.candidate) sendSignal("candidate", event.candidate);
      };
      pc.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
          if (!remoteStream.getTracks().some(t => t.id === track.id)) {
            remoteStream.addTrack(track);
          }
        });
        // Actualizar el video principal y miniaturas si corresponde
        updateLayout();
      };
      pc.onconnectionstatechange = () => {
        if (["disconnected", "closed", "failed"].includes(pc.connectionState)) {
          hangupCall();
        }
      };
      return pc;
    }

    async function iniciarConexion(userId) {
      localUserId = userId;
      connection = new signalR.HubConnectionBuilder()
        .withUrl(`https://signalr2.onrender.com/chathub?userId=${userId}`)
        .configureLogging(signalR.LogLevel.Information)
        .build();
		
		<!-- connection = new signalR.HubConnectionBuilder() -->
    <!-- .withUrl(`https://signalr2.onrender.com/chathub?userId=${userId}`, { -->
        <!-- transport: signalR.HttpTransportType.WebSockets -->
    <!-- }) -->
    <!-- .configureLogging(signalR.LogLevel.Information) -->
    <!-- .build(); -->

      connection.on("RecibirOferta", async (json, emisorId) => {
        console.log("[SignalR] Recibida oferta de:", emisorId, json);
        const data = JSON.parse(json);
        remoteUserId = emisorId;
        if (pc) hangupCall(false);
        pc = createPeerConnection();
        if (!localStream) {
          console.log("[startCall] Solicitando acceso a cámara/micrófono...");
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
          if (miniLocalNormal) miniLocalNormal.srcObject = localStream;
        }
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        await pc.setRemoteDescription(new RTCSessionDescription(data));
        for (const cand of pendingCandidates) await pc.addIceCandidate(new RTCIceCandidate(cand));
        pendingCandidates = [];
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignal("answer", answer);
      });

      connection.on("RecibirRespuesta", async (json) => {
        console.log("[SignalR] Recibida respuesta:", json);
        const data = JSON.parse(json);
        if (!pc) return;
        await pc.setRemoteDescription(new RTCSessionDescription(data));
        for (const cand of pendingCandidates) await pc.addIceCandidate(new RTCIceCandidate(cand));
        pendingCandidates = [];
      });

      connection.on("RecibirIceCandidate", async (json) => {
        console.log("[SignalR] Recibido candidato ICE:", json);
        const data = JSON.parse(json);
        if (pc && pc.remoteDescription && pc.remoteDescription.type) {
          await pc.addIceCandidate(new RTCIceCandidate(data));
        } else {
          pendingCandidates.push(data);
        }
      });

      connection.on("ModoPantallaRemoto", (activo) => {
        if (activo) {
          mainCall.classList.add("screen-mode");
        } else {
          mainCall.classList.remove("screen-mode");
        }
      });

      try {
        await connection.start();
        console.log("Conectado a SignalR");
      } catch (err) {
        alert("Error conexión SignalR: " + err);
      }
    }

    function sendSignal(type, data) {
      if (!remoteUserId || !connection) {
        console.warn("[sendSignal] No hay remoteUserId o conexión");
        return;
      }
      const payload = JSON.stringify(data);
      console.log(`[sendSignal] Enviando señal: ${type} a ${remoteUserId}`, data);
      switch (type) {
        case "offer": connection.invoke("EnviarOferta", remoteUserId, payload); break;
        case "answer": connection.invoke("EnviarRespuesta", remoteUserId, payload); break;
        case "candidate": connection.invoke("EnviarIceCandidate", remoteUserId, payload); break;
      }
    }

    async function startCall(remoteId) {
      console.log("[startCall] Iniciando llamada a:", remoteId);
      if (!connection || connection.state !== "Connected") {
        console.warn("[startCall] No hay conexión activa a SignalR");
        alert("Primero debes iniciar la conexión"); return;
      }
      remoteUserId = remoteId;
      if (pc) hangupCall(false);
      pc = createPeerConnection();
      if (!localStream) {
        console.log("[startCall] Solicitando acceso a cámara/micrófono...");
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        if (miniLocalNormal) miniLocalNormal.srcObject = localStream;
      }
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      console.log("[startCall] Oferta creada y localDescription seteada. Enviando señal...");
      sendSignal("offer", offer);
      updateLayout();
    }

    function hangupCall() {
      if (pc) { pc.close(); pc = null; }
      if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
      if (remoteStream) { remoteStream.getTracks().forEach(track => track.stop()); remoteStream = null; }
      if (miniLocalNormal) miniLocalNormal.srcObject = null;
      if (mainVideo) mainVideo.srcObject = null;
      afterCallUpdateLayout();
    }

    chatButton.addEventListener('click', () => {
      callChat.classList.toggle('active');
      mainCall.classList.toggle('chat-open');
    });

    document.querySelector('.toggle-camera').addEventListener('click', function() {
      const icon = this.querySelector('i');
      const on = this.getAttribute('data-active') === 'true';
      icon.className = on ? 'ph ph-camera-slash' : 'ph ph-camera';
      this.setAttribute('data-active', !on);
      if (!localStream) return;
      const video = localStream.getVideoTracks()[0];
      if (video) video.enabled = !video.enabled;
    });

    document.querySelector('.toggle-mic').addEventListener('click', function() {
      const icon = this.querySelector('i');
      const on = this.getAttribute('data-active') === 'true';
      icon.className = on ? 'ph ph-microphone-slash' : 'ph ph-microphone';
      this.setAttribute('data-active', !on);
      if (!localStream) return;
      const audio = localStream.getAudioTracks()[0];
      if (audio) audio.enabled = !audio.enabled;
    });

    document.querySelector('.end-call').onclick = () => {
      hangupCall();
    };

    emojiToggle.addEventListener('click', e => {
      emojiPanel.style.display = emojiPanel.style.display === 'flex' ? 'none' : 'flex';
      e.stopPropagation();
    });

    emojiPanel.querySelectorAll('span').forEach(s => {
      s.addEventListener('click', () => {
        emojiFloat.textContent = s.textContent;
        emojiFloat.classList.add('show');
        emojiPanel.style.display = 'none';
        setTimeout(() => emojiFloat.classList.remove('show'), 1500);
      });
    });

    window.addEventListener('click', e => {
      if (!emojiPanel.contains(e.target) && !emojiToggle.contains(e.target))
        emojiPanel.style.display = 'none';
    });

    let screenStream = null;
    let isScreenSharing = false;

    // Añadir helpers para distinguir tracks de cámara y pantalla
    function getCameraTrack(stream) {
      if (!stream) return null;
      return stream.getTracks().find(t => t.kind === 'video' && t.label.toLowerCase().indexOf('screen') === -1);
    }
    function getScreenTrack(stream) {
      if (!stream) return null;
      return stream.getTracks().find(t => t.kind === 'video' && t.label.toLowerCase().indexOf('screen') !== -1);
    }

    function setLayoutNormal() {
      mainCall.classList.remove("screen-mode");
      // Video grande: el de la otra persona (cámara)
      if (typeof mainVideo !== 'undefined' && mainVideo && remoteStream) {
        const remoteCameraTrack = getCameraTrack(remoteStream);
        if (remoteCameraTrack) {
          // Creamos un nuevo MediaStream solo con la cámara remota
          const camStream = new MediaStream([remoteCameraTrack]);
          mainVideo.srcObject = camStream;
          if (typeof mainAvatar !== 'undefined' && mainAvatar) mainAvatar.style.display = "none";
          if (typeof mainName !== 'undefined' && mainName) mainName.textContent = remoteUserId || "Remoto";
        } else {
          mainVideo.srcObject = null;
          if (typeof mainAvatar !== 'undefined' && mainAvatar) mainAvatar.style.display = "block";
          if (typeof mainName !== 'undefined' && mainName) mainName.textContent = remoteUserId || "Remoto";
        }
      }
      // Miniatura: tu propia cámara
      if (typeof miniaturaNormal !== 'undefined' && miniaturaNormal) miniaturaNormal.style.display = "flex";
      if (typeof miniLocalNormal !== 'undefined' && miniLocalNormal && localStream) {
        const localCameraTrack = getCameraTrack(localStream);
        if (localCameraTrack) {
          miniLocalNormal.srcObject = new MediaStream([localCameraTrack]);
        } else {
          miniLocalNormal.srcObject = null;
        }
      }
      var miniaturasPanel = document.getElementById("miniaturasPanel");
      if (miniaturasPanel) miniaturasPanel.style.display = "none";
    }

    function setLayoutScreenShare() {
      mainCall.classList.add("screen-mode");
      // Video grande: pantalla compartida
      if (typeof mainVideo !== 'undefined' && mainVideo) {
        // Si soy quien comparte, uso mi propio screenStream
        if (screenStream && isScreenSharing) {
          mainVideo.srcObject = screenStream;
          if (typeof mainAvatar !== 'undefined' && mainAvatar) mainAvatar.style.display = "none";
          if (typeof mainName !== 'undefined' && mainName) mainName.textContent = "Pantalla";
        } else {
          // Si soy quien recibe, busco el track de pantalla en remoteStream
          const remoteScreenTrack = getScreenTrack(remoteStream);
          if (remoteScreenTrack) {
            mainVideo.srcObject = new MediaStream([remoteScreenTrack]);
            if (typeof mainAvatar !== 'undefined' && mainAvatar) mainAvatar.style.display = "none";
            if (typeof mainName !== 'undefined' && mainName) mainName.textContent = "Pantalla";
          } else {
            mainVideo.srcObject = null;
            if (typeof mainAvatar !== 'undefined' && mainAvatar) mainAvatar.style.display = "block";
            if (typeof mainName !== 'undefined' && mainName) mainName.textContent = "Pantalla";
          }
        }
      }
      // Oculta miniatura normal
      if (typeof miniaturaNormal !== 'undefined' && miniaturaNormal) miniaturaNormal.style.display = "none";
      // Muestra panel de miniaturas
      actualizarMiniaturasPanel();
      var miniaturasPanel = document.getElementById("miniaturasPanel");
      if (miniaturasPanel) miniaturasPanel.style.display = "flex";
    }

    function actualizarMiniaturasPanel() {
      const miniaturasPanel = document.getElementById("miniaturasPanel");
      if (!miniaturasPanel) return;
      miniaturasPanel.innerHTML = "";
      // Miniatura local (cámara)
      const miniLocal = document.createElement("div");
      miniLocal.className = "video-mini";
      const videoLocal = document.createElement("video");
      videoLocal.autoplay = true;
      videoLocal.muted = true;
      videoLocal.playsInline = true;
      const localCameraTrack = getCameraTrack(localStream);
      if (localCameraTrack) videoLocal.srcObject = new MediaStream([localCameraTrack]);
      miniLocal.appendChild(videoLocal);
      const avatarLocal = document.createElement("div");
      avatarLocal.className = "avatar";
      avatarLocal.textContent = userIdInput && userIdInput.value ? userIdInput.value.substring(0,2).toUpperCase() : "YO";
      miniLocal.appendChild(avatarLocal);
      const nameLocal = document.createElement("div");
      nameLocal.className = "mini-name";
      nameLocal.textContent = "Tú";
      miniLocal.appendChild(nameLocal);
      miniaturasPanel.appendChild(miniLocal);
      // Miniatura remota (cámara)
      const miniRemote = document.createElement("div");
      miniRemote.className = "video-mini";
      const videoRemote = document.createElement("video");
      videoRemote.autoplay = true;
      videoRemote.playsInline = true;
      const remoteCameraTrack = getCameraTrack(remoteStream);
      if (remoteCameraTrack) videoRemote.srcObject = new MediaStream([remoteCameraTrack]);
      miniRemote.appendChild(videoRemote);
      const avatarRemote = document.createElement("div");
      avatarRemote.className = "avatar";
      avatarRemote.textContent = remoteUserId ? remoteUserId.substring(0,2).toUpperCase() : "R";
      miniRemote.appendChild(avatarRemote);
      const nameRemote = document.createElement("div");
      nameRemote.className = "mini-name";
      nameRemote.textContent = remoteUserId || "Remoto";
      miniRemote.appendChild(nameRemote);
      miniaturasPanel.appendChild(miniRemote);
    }

    // Cambia el layout según el modo
    function updateLayout() {
      if (isScreenSharing) {
        setLayoutScreenShare();
      } else {
        setLayoutNormal();
      }
    }

    screenToggle.onclick = async () => {
      if (!localStream || !pc) {
        isScreenSharing = false;
        updateLayout();
        return;
      }
      try {
        if (!isScreenSharing) {
          // Iniciar compartir pantalla
          screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
          isScreenSharing = true;
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender && screenStream.getVideoTracks().length > 0) {
            sender.replaceTrack(screenStream.getVideoTracks()[0]);
            if (connection) connection.invoke("CambiarModoPantalla", remoteUserId, true);
          }
          screenStream.getVideoTracks()[0].onended = () => {
            // Al dejar de compartir
            if (sender && localStream.getVideoTracks().length > 0) {
              sender.replaceTrack(localStream.getVideoTracks()[0]);
              if (connection) connection.invoke("CambiarModoPantalla", remoteUserId, false);
            }
            isScreenSharing = false;
            screenStream = null;
            updateLayout();
          };
        } else {
          // Detener compartir pantalla manualmente
          if (screenStream) {
            screenStream.getTracks().forEach(track => track.stop());
            screenStream = null;
          }
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender && localStream && localStream.getVideoTracks().length > 0) {
            sender.replaceTrack(localStream.getVideoTracks()[0]);
            if (connection) connection.invoke("CambiarModoPantalla", remoteUserId, false);
          }
          isScreenSharing = false;
        }
        updateLayout();
      } catch (e) {
        console.error("Error al compartir pantalla:", e);
      }
    };

    // Escuchar cambios de modo de pantalla desde el remoto
    connection?.on && connection.on("ModoPantallaRemoto", (activo) => {
      isScreenSharing = activo;
      updateLayout();
    });

    // Al iniciar o terminar llamada, actualizar layout
    function afterCallUpdateLayout() {
      isScreenSharing = false;
      screenStream = null;
      updateLayout();
    }

    // Llamar afterCallUpdateLayout en los lugares correctos
    function hangupCall() {
      if (pc) { pc.close(); pc = null; }
      if (localStream) { localStream.getTracks().forEach(track => track.stop()); localStream = null; }
      if (remoteStream) { remoteStream.getTracks().forEach(track => track.stop()); remoteStream = null; }
      if (miniLocalNormal) miniLocalNormal.srcObject = null;
      if (mainVideo) mainVideo.srcObject = null;
      afterCallUpdateLayout();
    }

    // Al recibir nueva llamada o respuesta, actualizar layout
    connection?.on && connection.on("RecibirOferta", async (json, emisorId) => {
      console.log("[SignalR] Recibida oferta de:", emisorId, json);
      const data = JSON.parse(json);
      remoteUserId = emisorId;
      if (pc) hangupCall(false);
      pc = createPeerConnection();
      if (!localStream) {
        console.log("[startCall] Solicitando acceso a cámara/micrófono...");
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        if (miniLocalNormal) miniLocalNormal.srcObject = localStream;
      }
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      await pc.setRemoteDescription(new RTCSessionDescription(data));
      for (const cand of pendingCandidates) await pc.addIceCandidate(new RTCIceCandidate(cand));
      pendingCandidates = [];
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      sendSignal("answer", answer);
      updateLayout();
    });
    connection?.on && connection.on("RecibirRespuesta", async (json) => {
      console.log("[SignalR] Recibida respuesta:", json);
      const data = JSON.parse(json);
      if (!pc) return;
      await pc.setRemoteDescription(new RTCSessionDescription(data));
      for (const cand of pendingCandidates) await pc.addIceCandidate(new RTCIceCandidate(cand));
      pendingCandidates = [];
      afterCallUpdateLayout();
    });

    // Al iniciar conexión, actualizar layout
    startConnectionBtn.addEventListener("click", () => {
      const userId = userIdInput.value.trim();
      if (!userId) {
        alert("Por favor ingresa tu ID antes de conectar.");
        return;
      }
      iniciarConexion(userId);
      afterCallUpdateLayout();
    });

    btnLlamar.addEventListener("click", () => {
      const remoteId = remoteIdInput.value.trim();
      console.log("[UI] Botón Llamar presionado. remoteId:", remoteId);
      if (remoteId) {
        startCall(remoteId);
      } else {
        alert("Por favor ingresa el ID remoto.");
      }
    });

    // Inicializar layout al cargar
    updateLayout();
  </script>
</body>
</html>
